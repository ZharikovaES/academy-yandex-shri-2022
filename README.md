# Академия Яндекса. Школа разработки интерфейсов
## Задача 1. Объявление
Задача написать JavaScript-функцию, которая разместит блоки с текстом как газетные колонки.  
Была реализована функция `renderWaterfall`. На вход она принимает следующие параметры:  
- `rootNode`: элемент, в котором находятся объявления (`HTMLDivElement`);
- `columnCount`: количество колонок (`number`);
- `elementGap`: расстояние между колонками, а также элементами по-вертикали (`number`).  

При вызове функция `renderWaterfall` должна была расположить DOM-элементы объявлений так, чтобы они разместились в `columnsCount` колонок, а расстояние между ними составляло `elementGap`. Каждый следующий элемент должен был помещаться в ту колонку, высота которой меньше остальных. При равных наименьших высотах элемент должен был помещаться в первую колонку слева.  
Решение представлено в файле `main.js` в директории `./task1`.  
Для демонстрации работы необходимо открыть в браузере файл `index.html` из директории `./task1`.
## Задача 2. Лабиринт
Нужно написать функцию для выхода из лабиринта, при этом гарантируется, что выход есть всегда.  
Функция `main` принимает на вход начальную точку `start` и объект `game` для взаимодействия с лабиринтом и возвращает точку `{ x, y }`, для которой `game.state(x, y).finish === true`.  
Было запрещено деструктурировать `game`. У `game` есть асинхронные функции, которые позволяют двигаться от любой ячейки влево, вправо, вверх или вниз. При попытке шагнуть в стену или из непосещённой клетки методы кидают ошибку. Также асинхронная функция получения состояния ячейки работает только для посещённых ячеек, для остальных – кидает ошибку.  
Ось `x` в лабиринте идет слева-направа, `y` - сверху-вниз.  
Решение представлено в файле `main.js` в директории `./task2/src`.  
Для демонстрации корректности работы необходимо запустить решение (`npm i && npm start`).  
## Задача 3. Figma to HTML
Нужно написать функцию, которая преобразует JSON-файл (представление макета Figma) в HTML, а затем вернет HTML в виде строки.  
Решение представлено в файле `index.js` в директории `./task3/solution`.  
Для демонстрации работы необходимо запустить файл `run.js` (`node run.js`), расположенный в директории `./task3`, и открыть в браузере файл `index.html` из директории `./task3/output`.  
## Задача 5. Применить стили
Дан набор CSS-правил и HTML-дерево, требуется применить CSS и выдать итоговый HTML. Нужно написать функцию, которая установит в свойства `styles` HTML-элементов финальные значения и вернёт это дерево.  
Ограничения:  
- Селекторы содержат только теги.
- Максимальное количество тегов в одном селекторе — два (если есть комбинатор).
- Селекторы, которые содержат только один тег, идут раньше других селекторов, т.е. сначала будут идти правила вида `tag1` и `tag2`, а уже потом – `tag1 tag2`.
- Есть следующие комбинаторы, с правилами как в CSS:  
    - `tag1 tag2`;
    - `tag1 > tag2`;
    - `tag1 + tag2`;
    - `tag1 ~ tag2`.
- CSS содержит правила только на наследуемые свойства, такие как `color`, `font-size` и т.д. (https://developer.mozilla.org/ru/docs/Web/CSS/inheritance#inherited_properties). Это значит, что если, к примеру, у родителя задан цвет, то его надо выставить и у детей.
- Для корневого элемента HTML в стилях заданы все возможные свойства потомков (не значения, а именно свойства, такие как `color` и т.д.). Т.е. если какой-то из потомков задаёт цвет, то для корневого элемента цвет будет тоже задан.
- Цвета будут заданы в формате `rgb(0, 255, 0)`.
- В CSS не будет сокращенных свойств, таких как `background`, `font`.
- Правила не содержат такие значения как `inherit`, `unset` и т.д.
- Поле `styles` изначально пустое (`{}`) для всех элементов.  

Решение представлено в файле `main.js` в директории `./task5/src`.  
Для демонстрации корректности работы необходимо запустить решение (`npm i && npm start`).
## Задача 6. Drag and Drop
Есть упрощённый интерфейс работы с электронной почтой. Нужно реализовать возможность расставлять теги на письма, используя drag and drop API.  
Есть две основные зоны: зона с тегами и зона с письмами. Теги можно перетаскивать из зоны всех тегов на письма и между письмами, а также снимать с писем, перетаскивая обратно в зону тегов.  
Если начать перетаскивать тег, то:  
- Тегу должен быть присвоен класс `Tag_dragged` — это позволит перетаскиваемому тегу иметь специальное отображение.
- Зоне писем должен быть присвоен класс `Letters_dropzone` — это позволит подсветить возможное назначение для перетаскивания.
- Если тег перетаскивается с письма, то дополнительно зоне тегов должен быть присвоен класс `Tags_dropzone` — это позволит подсветить ещё одно возможное назначение для перетаскивания.

При перетаскивании тега:
- На письмо, на котором данный тег отсутствует, письму присваивается класс `Letter_dragovered` — это позволяет подсвечивать только те письма, на которые можно бросить данный тег.
- С письма на зону тегов, зоне тегов должен быть присвоен класс `Tags_dragovered` — это позволит подсветить возможность бросить тег.  

При броске тега на письмо, на котором данный тег отсутствует, он должен быть на него проставлен. При этом новый тег должен оказаться после всех существующих. Если тег перетаскивался с другого письма, то он должен исчезнуть с исходного.  
При перетаскивании тега с письма на зону тегов, он должен сниматься с письма.  
Для демонстрации работы необходимо открыть в браузере файл `index.html` из директории `./task6`.
## Задача 7. Zoom раскладка
В видеоконференции участвует n участников, у каждого из них – одинаковое разрешение видео и экрана, к примеру, `1200x800`. Требуется написать  функцию раскладки видео участников на экране звонка.  
Раскладка должна быть симметричной относительно вертикали, все карточки видео должны быть одинакового размера и иметь такие же соотношения высоты и ширины, как и экран. Если карточек не хватает для заполнения строки, то такая строка должна быть расположена первой сверху.  
Пустое пространство выше и ниже строк должно иметь одинаковую высоту.  
Нумерация карточек идет сверху вниз и слева направо, в таком же порядке их должна вернуть функция. Координаты идут по `x` слева направо, по `y` – сверху вниз.  
Координаты карточек и их размер нужно округлить до ближайших целых значений, используя `Math.round`.  
Для демонстрации работы необходимо вызвать функцию `main` из файла `index.js` из директории `./task7` с параметрами:  
- `n` - число карточек (`number`);
- `width` - ширина экрана (`number`);
- `height` - высота экрана (`number`).
